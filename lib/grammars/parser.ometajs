var _     = require('../nodes')
  , utils = require('../utils');

ometa Parser {
  _                = spaces,
  spacesNoNl       = (~'\n' space)*,
  sc               = spacesNoNl ('\n' | &'}' | end),
  
  
  identFirst       = letter | '$' | '_',
  identRest        = identFirst | digit | '?',
  identifier       = _ <identFirst identRest*>:id                                         -> _.Id(id),
  
  hexDigit         = char:x {"0123456789abcdef".indexOf(x.toLowerCase())}:v ?(v >= 0)     -> v,
  hex              = <``0x'' hexDigit+>:d                                                 -> _.Number(parseInt(d)).kind('hex'),
  
  decimalInt       = '0' | (~'0' digit) (digit | '_')*,
  expPart          = ('e' | 'E') ('+' | '-')? digit+,
  
  decimal          = <'-'? decimalInt ('.' digit+)? expPart?>:f                           -> _.Number(f)
                   | <'-'? ('.' digit+) expPart?>:f                                       -> _.Number(f),
  
  number           = _ (hex | decimal),
  
  // allows string-substitution like "foo #{bar} baz"
  escapeSeq        = <'\\' ( 'u' hexDigit hexDigit hexDigit hexDigit
                           | 'x' hexDigit hexDigit
                           | char                                    
                           )>:s                                                           -> unescape(s),
  strSubst         = ``#{'' _ messageSend:e _ '}'                                                -> e,
  strPart          = <(escapeSeq | ~('"'| ``#{'') char)+>:cs                              -> _.String(cs),
  string           = _ (``""''                                                            -> _.String("") //preserve empty strings
                       | '"' (strSubst | strPart)+:cs '"'                                 -> _.StringExpr(cs)
                       ),

  reBody           = reFirst reChar*,
  reChar           = reFirst | '*',
  reFirst          = ~('*' | '/' | '[') reClassChar
                   | reClass
                   | ']',
  reClass          = '[' reClassChar* ']',
  reClassChar      = escapeSeq
                   | ~(']' | '\\' | '\n' | '\r') char,
  reFlag           = letter,
  regexp           = _ '/' <reBody>:b '/' <reFlag+>:f                                     -> _.RegExp(b).flags(f)
                   | _ '/' <reBody>:b '/'                                                 -> _.RegExp(b),
  
  lambda           = _ '{' _ listOf(#identifier, ","):args _ '|' _ exprs:exprs _ '}'      -> _.Lambda(_.FunArgs(args), _.FunBody(exprs))
                   | _ '{' _ exprs:exprs _ '}'                                            -> _.Lambda(_.FunArgs([]),   _.FunBody(exprs)),
  
  map              = _ '{' _ ( ':'                                                        -> _.Map()
                             | listOf(#mapBinding, ","):bs                                -> _.Map(bs)
                             ):map
                        _ '}'                                                             -> map,
  mapBinding       = _ messageSend:n _ ':' _ messageSend:v                                -> _.KeyValuePair(n, v),
  
  array            = _ '[' _ listOf(#messageSend, ","):exprs _ ']'                        -> _.Array(exprs),
  
  assignOp         = ( ``:='' | ``+=''  | ``-='' | ``*=''  | ``/='' | ``%=''   | ``<<='' 
                     | ``^='' | ``&&='' | ``&='' | ``||='' | ``|='' | ``>>>='' | ``>>=''
                     ),
  orOp             = ( ``||'' | ``or''  ),
  andOp            = ( ``&&'' | ``and'' ),
  bitOrOp          =   ``|'',
  bitXorOp         =   ``^'',
  bitAndOp         =   ``&'',
  eqOp             = ( ``=''  | ``!='' ),
  relOp            = ( ``<='' | ``<''  | ``>='' | ``>'' ),
  shiftOp          = ( ``>>>''| ``>>'' | ``<<'' ),
  addOp            = ( ``+''  | ``-'' ),
  mulOp            = ( ``*''  | ``/'' ),
  
  binaryMessage    = orExpr:lhs       ( _ assignOp:op _ messageSend:rhs                    -> _.BinaryMsg(lhs, rhs).operator(op).
                                                                                                                    assignment(true)
                                      |   empty                                            -> lhs
                                      ),
  orExpr           = andExpr:lhs      ( _ orOp:op _ messageSend:rhs                        -> _.BinaryMsg(lhs, rhs).operator(op)
                                      |   empty                                            -> lhs
                                      ),
  andExpr          = bitOrExpr:lhs    ( _ andOp:op _ messageSend:rhs                       -> _.BinaryMsg(lhs, rhs).operator(op)
                                      |   empty                                            -> lhs
                                      ),
  bitOrExpr        = bitXorExpr:lhs   ( _ bitOrOp:op _ messageSend:rhs                     -> _.BinaryMsg(lhs, rhs).operator(op)
                                      |   empty                                            -> lhs
                                      ),
  bitXorExpr       = bitAndExpr:lhs   ( _ bitXorOp:op _ messageSend:rhs                    -> _.BinaryMsg(lhs, rhs).operator(op)
                                      |   empty                                            -> lhs
                                      ),
  bitAndExpr       = eqExpr:lhs       ( _ bitAndOp:op _ messageSend:rhs                    -> _.BinaryMsg(lhs, rhs).operator(op)
                                      |   empty                                            -> lhs
                                      ),
  eqExpr           = relExpr:lhs      ( _ eqOp:op _ messageSend:rhs                        -> _.BinaryMsg(lhs, rhs).operator(op)
                                      |   empty                                            -> lhs
                                      ),
  relExpr          = shiftExpr:lhs    ( _ relOp:op _ messageSend:rhs                       -> _.BinaryMsg(lhs, rhs).operator(op)
                                      |   empty                                            -> lhs
                                      ),
  shiftExpr        = primExpr,
  
  // Dummy expr for now
  primExpr         = '(' messageSend:e ')'                                                 -> e
                   | identifier
                   | string
                   | number
                   | regexp
                   | lambda
                   | map
                   | array,
  
  messageSend      = binaryMessage,
  
  expr             = messageSend:expr sc                                                  -> expr,
  
  exprs            = expr*,
  
  topLevel         = exprs:exprs _ end                                                    -> _.File(exprs)
}

Parser.position = function (token) {
  var len      = this.input.lst.length;
  var lines    = this.input.lst.substr(0, len - (len - this.input.idx)).split('\n');
  var line     = lines.length - 1;
  var end      = lines[line].length - 1;
  var start    = end - (token.length - 1);
  return {line: line, start: start, end: end};
};

Parser.parse = function (source, fname, rule) {
  var tree = Parser.matchAll(source, rule || 'topLevel', []);
  tree.define_keyword('to_s',       function () { return utils.to_string(this);        });
  tree.define_keyword('print',      function () { console.log(this.to_s());            });
  tree.define_keyword('print_tree', function () { console.log(utils.print_tree(this)); });
  
  return tree.name ? tree.name(fname) : tree;
};

Parser.parseFrom = function (source, rule, fname) {
  return this.parse(source, fname || '', rule);
};