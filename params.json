{"body":"# Espresso\r\n\r\nEspresson is an experimental dynamic, prototype-based, object-oriented programming language that compiles down to JavaScript.\r\n\r\nWhile it is object-oriented it's still very different from most modern languages, for instance you won't find any classes or variables, instead there are only objects and slots, even lexical scope is implemented entirely in terms of language primitives.\r\n\r\nThe way you communicate with objects in Espresso is by sending messages of which there are three kinds: unary, binary and keyword.\r\n\r\nEspresso also has, although currently very limited, support for predicate dispatch.\r\n\r\n## Install\r\n\r\n    npm install -g espresso-language\r\n\r\nThis will install the Espresso compiler (esc) globally on your machine.\r\n\r\nTo run a Espresso script just type `esc name.es`, if you would rather compile it to a js file type `esc name.es --compile` which will create a JavaScript file with the same basename in the current directory (name.js in this case).\r\n\r\nExecuting `esc` without any arguments launches a (very basic) REPL.\r\n\r\nFor more information run `esc --help`\r\n\r\nNote: This requires that you have nodejs v0.8.8 and npm installed already.\r\n\r\n## Hello, world!\r\n\r\nSo, let's look att how Epresso works. We'll start with the ever present Hello, world:\r\n\r\n    \"Hello, world!\" println //=> \"Hello, world!\"\r\n\r\nHere we are sending the unary message `println` to a string object containing `Hello, world!`. In this case, since println is a method, it results in a method call but it could just as well have been a regular slot access and it would have looked just the same.\r\n\r\nNow, let's expand this example and introduce a few more concepts:\r\n\r\n    Greeter = Object clone\r\n    Greeter greet: name with: message := {\r\n      \"#{message}, #{name}!\" println\r\n    }\r\n    \r\n    Greeter greet: \"world\" with: \"Hello\" //=> \"Hello, world!\"\r\n\r\nWe begin by sending the `clone` message to the prototypical `Object` object, this returns a brand new object who's prototype points to `Object` and then assign it to `Greeter`.\r\nNext we define the `greet:with:` message on `Greeter`, the := operator signifies to the compiler that this should be treated as a method.\r\nFinally we send the `greet:with:` message to the `Greeter` object.\r\nOne thing you may note is that the name of this message and it's arguments are mixed togheter, this is called a keyword message, but the name actually is `greet:with:` and you can validate this by asking `Greeter` for a reference to it rather than executing it, like so:\r\n\r\n    greet = Greeter get: 'greet:with:\r\n    greet call: \"world\", \"Hello\" //=> \"Hello, world!\"\r\n\r\nThe `get:` message returns a method reference that we can `call:`. It takes a variadic number of arguments and will by default execute in the context of it's original receiver, in this case Greeter, though you can override that choice by sending the `call:as:` message instead.\r\n\r\nNow, you may be wondering about `Greeter` and `greet` since I earlier told you that there are no variables in Espresso, but they sure do look like variables don't they? Well, actually they are slots on an object, in this case the top-level object `Lobby`.\r\n\r\n    Lobby println // => Lobby\r\n                          Lobby\r\n                          type\r\n                          unknown-slot:args:\r\n                          to-s\r\n                          Object\r\n                          Lambda\r\n                          Number\r\n                          String\r\n                          Array\r\n                          Boolean\r\n                          RegExp\r\n                          nil\r\n                          traits\r\n                      >>> Greeter\r\n                      >>> greet\r\n\r\nWith that out of the way, let's return to our friend the Greeter and extend it further:\r\n\r\n    Greeter = Object clone\r\n    Greeter greet: someone with: message := {\r\n      \"#{name} says: #{message}, #{someone name}\" println\r\n    }\r\n    \r\n    g1 = Greeter clone: @{ name = \"G1\" }\r\n    g2 = Greeter clone: @{ name = \"G2\" }\r\n    \r\n    g1 greet: g2 with: \"Hello\" //=> \"G1 says: Hello, G2!\"\r\n\r\nWhat we see here is a common architectural technique in prototype based languages, namely separating data from behavior. Our prototypical Greeter object depends on a name slot being defined but it never defines it rather it expects that any object which clones it does, in this case that would be g1 and g2.\r\n\r\nAs you can see, g1 can now greet g2 with a nice message. But there's a slight problem here, and that is, our `greet:with:` method is very specific in that it requires it's first argument to be an object with a name slot. What if we wanted it to call it with a string instead?\r\n\r\n    g1 greet: \"world\" with: \"Hello\" //=> \"g1 says: Hello, nil!\"\r\n\r\nHmm, not exactly what we wanted. Now we could solve that using a conditional inside the `greet:with:` method but then it wouldn't be possible to extend it further without changing that method. This is where predicate dispatch comes in handy:\r\n\r\n    Greeter greet: someone with: message := {\r\n      \"#{name} says: #{message}, #{someone}!\" println\r\n    }\r\n    \r\n    Greeter greet: someone @{understands?: 'name} with: message := {\r\n      greet: someone name with: message\r\n    }\r\n    \r\n    \r\n    g1 greet: \"world\" with: \"Hello\" //=> \"P1 says: Hello, world!\"\r\n    g1 greet: g2      with: \"Hello\" //=> \"P1 says: Hello, P2!\"\r\n\r\nNow we have two implementations of `greet:with:` a specific one which requires a named object and a general one that accepts any object. The great thing about this is that it can be extended further, even by third party code, without needing to change the original definition. ","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A prototype-based programming language inspired by Self, Io, Ruby and Smalltalk","google":"","name":"Espresso"}